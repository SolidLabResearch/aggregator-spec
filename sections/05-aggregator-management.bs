Aggregator Management {#aggregator-management}
==================================================================
This section describes how Aggregator Instances are managed at the Aggregator Server level. Deployments define their own 
authorization policy for these endpoints, but they MUST require authenticated requests so the Aggregator provider can 
authorize a user to manage their aggregators. The tokens used in these requests (`IDP_client_token`) prove the identity of 
the user and the client (Client ID Document) used to access the Aggregator Server. Deployments MAY expose the same 
functionality at different paths, provided that the Aggregator Server Description advertises the authoritative URLs.

Aggregator Registration Endpoint {#aggregator-registration}
--------------------------------------------------------
This section specifies the behavior of the `registration_endpoint` advertised by the Aggregator Server Description 
([[#server-description]]). The endpoint supports creating Aggregator Instances, replacing the stored token set for an 
existing instance, and deleting an instance. If the `registration_type` isn't `none` the endpoint SHOULD reject 
unauthenticated requests with `401 Unauthorized`.

ISSUE: should we allow a name field for the aggregator during creation?

: `POST`
:: Creates an Aggregator Instance or replaces the stored token set for an existing instance.
    The request body MUST use a content type listed in `registration_request_formats_supported` and MUST include:
    When using `application/json`, the body MUST be a JSON object. When using
    `application/x-www-form-urlencoded`, the body parameters MUST be encoded as form fields with the same
    member names.
    The server MUST support `application/json` and MAY support `application/x-www-form-urlencoded`.
    - **registration_type** (REQUIRED):
        The value is a string token; it MUST be one of the `supported_registration_types` advertised in the Aggregator 
        Server Description ([[#server-description]]). The following string tokens are defined, each corresponding to an RDF 
        class in the Aggregator vocabulary ([[#vocabulary]]) for semantically annotated representations:
        - `"none"` â†” `aggr:NoAuthFlow` ([[#aggr-no-auth-flow-class]])
        - `"provision"` â†” `aggr:ProvisionFlow` ([[#aggr-provision-flow-class]])
        - `"authorization_code"` â†” `aggr:AuthorizationCodeFlow` ([[#aggr-authorization-code-flow-class]])
        - `"device_code"` â†” `aggr:DeviceCodeFlow` ([[#aggr-device-code-flow-class]])
    - **aggregator** (string, OPTIONAL): When present, the request targets an existing Aggregator Instance and the server 
        MUST replace its stored access token and refresh token with a new set obtained from the Identity Provider (IdP). 
        This is not a refresh-token grant; it is a full re-authentication to obtain a fresh access token and refresh token.

    Depending on `registration_type`, additional members are defined:

    - **registration_type: "none"**
        - No additional members are required.

        In this flow the Aggregator Instance has no identity and all requests to upstream resource servers will be 
        unauthenticated. All hosted resources MUST be public or accessible without authentication. In this flow the 
        registration post request MIGHT not require authentication, depending on the deploymentâ€™s policy.

    - **registration_type: "provision"**
        - No additional members are required.

        In this flow the Aggregator server MUST provision an identity for the Aggregator Instance that is
        registered at the Identity Provider (IdP).

    - **registration_type: "authorization_code"**
        The `authorization_code` flow uses two `POST` messages to the `registration_endpoint`. It is based on the OAuth 
        2.0 Authorization Code grant [[RFC6749]] (https://datatracker.ietf.org/doc/html/rfc6749). The **Start Request** 
        bootstraps PKCE [[RFC7636]], the request body MUST include:
            - **registration_type** (string, REQUIRED): `"authorization_code"`.
            - **authorization_server** (string, REQUIRED): The URL of the UMA Authorization Server that governs access to
                resources exposed by the Aggregator.

        The server MUST respond with `201 Created` and a JSON object containing:
            - **aggregator_client_id** (string, REQUIRED): The Client ID Document of the aggregator.
            - **code_challenge** (string, REQUIRED)
            - **code_challenge_method** (string, REQUIRED)
            - **state** (string, REQUIRED)

        The server MAY also include IdP discovery hints (for example `issuer` or `authorization_endpoint`) if
        the client cannot determine them through other means.

        The **Finish Request** redeems the authorization code, the request body MUST include:
            - **registration_type** (string, REQUIRED): `"authorization_code"`.
            - **code** (string, REQUIRED): The authorization code issued by the IdP.
            - **redirect_uri** (string, REQUIRED): The redirect URI used in the authorization request.
            - **state** (string, REQUIRED): The `state` returned by the start request.

        The finish request reuses the stored `authorization_server` from the start request and the client SHOULD NOT 
        include it again. This flow uses two Client ID Documents: the Aggregator Client ID Document and
        the application Client ID Document identified by the client_id URI in the `aud` claim. If the Aggregator Client ID 
        Document ([[#client-id-document]]) doesn't have
        `redirect_uris` registered, the Aggregator Server MUST verify that `redirect_uri` in the request matches one of 
        the redirect URIs registered in the Client ID Document of the client application. The client application's
        Client ID Document MUST be the client_id URI in the `aud` claim of the `IDP_client_token` from the authorization header
        in the **Start Request** request. If the `aud` claim is missing or does not contain a dereferenceable client
        identifier, the server MUST respond with `400 Bad Request`. In deployments where the client application does not
        have a Client ID Document, the Aggregator Server MUST require `redirect_uris` to be registered in the 
        Aggregator Client ID Document which will be validated by the IDP. If the Aggregator Client ID Document has 
        `redirect_uris` registered, it MAY skip the Client ID Document check of the client application. In all cases, 
        the server MUST verify that the `state` matches the stored state for the pending registration.

    - **registration_type: "device_code"**
        The `device_code` flow uses two `POST` messages to the `registration_endpoint` and follows the OAuth 2.0
        Device Authorization Grant [[RFC8628]]. This flow is intended for headless components (for example CLI tools) 
        to authenticate an Aggregator Instance where the `authorization_code` flow is not practical. The **Start Request** 
        initiates device authorization flow and the request body MUST include:
        - **registration_type** (string, REQUIRED): `"device_code"`.
        - **authorization_server** (string, REQUIRED): The URL of the UMA Authorization Server that governs access to
            resources exposed by the Aggregator.

        The server MUST determine the IdP from the `IDP_client_token` in the authorization header (for example,
        via the `iss` claim and discovery), request device authorization at the IdP, securely store the returned 
        device_code, and respond with 201 Created and a JSON object containing:
        - **state** (string, REQUIRED): Opaque value used by the client to poll completion of the device flow.
        - **user_code** (string, REQUIRED): The end-user verification code issued by the IdP.
        - **verification_uri** (string, REQUIRED): The end-user verification URI on the IdP.
        - **verification_uri_complete** (string, OPTIONAL): A verification URI that includes the "user_code" (or other 
            information with the same function as the "user_code"), which is designed for non-textual transmission.
        - **expires_in** (number, REQUIRED): The lifetime in seconds of the device authorization session.
        - **interval** (number, OPTIONAL): Minimum polling interval in seconds, this may differ from the interval the 
            IdP recommends.

        The `device_code` is confidential and MUST NOT be returned to the client. The **Poll Request** checks whether the 
        user has authorized the device code. The client uses the `state` value to poll for completion, the request body 
        MUST include:
        - **registration_type** (string, REQUIRED): `"device_code"`.
        - **state** (string, REQUIRED): The `state` value returned by the start request.

        Unlike a traditional OAuth device flow, the client does not poll the IdP directly. Upon receiving a poll request, 
        the Aggregator MUST attempt to redeem the stored device_code at the IdP token endpoint 
        (grant_type=urn:ietf:params:oauth:grant-type:device_code). If authorization is not yet complete, the server MUST 
        respond with 202 Accepted. When authorization succeeds, the server creates (or updates) the Aggregator Instance and 
        responds as for other successful create/update operations (see below). If the device authorization session has 
        expired, the server MUST respond with 400 Bad Request. The device authorization session MUST be bound to the 
        authenticated caller.

    **Success responses**
    For successful `POST` requests that create/update an Aggregator Instance (i.e., provision, the 
    authorization_code finish request, and successful device_code poll requests), the server MUST respond with:
    - `201 Created` when it created a new Aggregator Instance (i.e., no `aggregator` was provided).
    - `200 OK` when it replaced the token set for an existing Aggregator Instance (i.e., `aggregator` was provided).

    For successful `POST` requests that create/update an Aggregator Instance (i.e., all types except the 
    `authorization_code` and `device_code` start requests), the response MUST be a JSON object and MUST include:
    - **aggregator** (string, REQUIRED): Absolute URL of the Aggregator Instance base URL that dereferences to
        the Aggregator Description ([[#aggregator-description]]).
    - **subject** (string, OPTIONAL): The WebID or Client_ID for which OIDC tokens were created. This MUST be
        added to the response when the request was a registration type `provision`.
    - **idp** (string, OPTIONAL): The Identity Provider (IdP) that issued the OIDC tokens for the Aggregator
        Instance. This MUST be added to the response when the request was a registration type `provision` and
        the subject is not a WebID.

    The server MUST NOT return any IdP access tokens, refresh tokens, or user credentials to the client.
    When a registration flow completes successfully (for example `provision`, `authorization_code` finish, or a successful
    `device_code` poll), the server obtains and stores an IdP access token for the Aggregator Instance (the
    `IDP_aggregator_token`) and an optionally accompanying refresh token. These tokens are used by the Aggregator for 
    upstream access and are not returned to the client.

    **Token replacement rules**
    To update the tokens for an existing Aggregator Instance, the client MUST include the `aggregator` member along with 
    the other required members for the selected `registration_type`. This SHOULD only be done for the following 
    `registration_type` values, for other values the server SHOULD respond with `400 Bad Request`:
    - `authorization_code`: To obtain a new access token and refresh token after the previous ones have expired.
    - `device_code`: To obtain a new access token and refresh token after the previous ones have expired.

: `GET`
:: This method returns the list of Aggregator Instances owned by the authenticated user. The server MUST respond with
    `200 OK` and a JSON array containing zero or more Aggregator Description URLs ([[#aggregator-description]]).

: `DELETE`
:: Deletes an existing Aggregator Instance. The request body MUST use a content type listed in
    `registration_request_formats_supported`. When using `application/json`, the body MUST be a JSON object.
    When using `application/x-www-form-urlencoded`, the body parameters MUST be encoded as form fields with
    the same member names. The request body MUST include:
    - **aggregator** (string, REQUIRED): Absolute URL of the Aggregator Instance base URL that dereferences to
        the Aggregator Description ([[#aggregator-description]]).

    If deletion succeeds the server MUST respond with `204 No Content`.


For error conditions, the server MUST respond with:
- `400 Bad Request` for a malformed request body or missing/invalid request members for the selected `registration_type`.
- `401 Unauthorized` when the request is missing authentication or when the `IDP_client_token` is invalid.
- `403 Forbidden` when the authenticated user is not allowed to manage the requested Aggregator Instance.
- `404 Not Found` when `aggregator` is provided but does not identify an existing Aggregator Instance. A `403 Forbidden`
    MAY also be returned in this case.
- `415 Unsupported Media Type` when the request format is not listed in `registration_request_formats_supported`.

Aggregator Management Flows (Non-normative) {#aggregator-management-flows}
--------------------------------------------------------
This section gives non-normative examples of how a client can use the `registration_endpoint` to create,
delete, and re-authenticate an Aggregator Instance.

### Creation `provision` Flow ### {#creation-provision}

The `provision` flow allows clients to create an Aggregator with its own identity.
This lets resource owners target access-control policies at the aggregatorâ€™s dedicated WebID instead of having
the aggregator impersonate another userâ€™s WebID.

**1. Client starts flow with Aggregator Server**

The client calls the registration endpoint authenticated with its `IDP_client_token`.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IDP_client_token>
Content-Type: application/json

{
  "registration_type": "provision"
}
```
</div>

**2. Aggregator Server provisions an account at an IDP**

The Aggregator Server provisions an account at an IDP. 
This might be linked to a WebID document that conforms to the WebID Profile specification [[!WEBID-PROFILE]].
Using the credentials of this account the Aggregator Server can perform a client credentials grant to obtain
the `IDP_aggregator_token` (and accompanying refresh token) to authorize the aggregator acting under its own
WebID.

**3. Aggregator Server creates an aggregator**

Using the obtained tokens, the Aggregator Server creates an aggregator linked to the user, and returns the
aggregator description ([[#aggregator-description]]).
The aggregator should not give these tokens or credentials to the client.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "aggregator": "https://aggregator.example/aggregators/agg-7890/",
  "subject": "https://aggregator.example/webid#me"
}
```
</div>

Or with a non-WebID subject:

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "aggregator": "https://aggregator.example/aggregators/agg-7890/",
  "subject": "aggregator@example.com",
  "idp": "https://idp.example/"
}
```
</div>

### Creation `authorization_code` Flow ### {#creation-authorization}

The `authorization_code` flow allows clients to create an aggregator that acts on behalf of the end-user, but
with a token that is scoped specifically for the aggregator. This flow follows the OAuth 2.0 Authorization
Code grant [[RFC6749]] (https://datatracker.ietf.org/doc/html/rfc6749).

<pre class="plantuml">
@startuml
skinparam participantStyle rectangle

participant User as "User ðŸ™‹"
participant Client as "Client ðŸ§‘â€ðŸ’»"
participant "IDP ðŸ”" as IDP
participant "Application Client ID Document ðŸ“„" as AppClientDoc
participant "Aggregator Server ðŸ¤–" as Aggregator
participant "Aggregator Client ID Document ðŸ“„" as AggregatorClientDoc

Client -> Aggregator: 1. Start aggregator creation
Aggregator --> Client: 1.1 Return flow parameters

Client -> IDP: 2. Redirect to IDP login
IDP <-> AggregatorClientDoc: 2.1 Dereference Aggregator Client ID Document
IDP <-> User: 3. Authenticate and consent
IDP --> Client: 4. Redirect with code + state

Client -> Aggregator: 5. Return code + redirect_uri + state
Aggregator <-> AppClientDoc: 5.1 Dereference Application Client ID Document
note over Aggregator: validate redirect_uri.
Aggregator -> IDP: 5.2 Redeem code
IDP --> Aggregator: IDP_aggregator_token + refresh_token

Aggregator --> Client: 5.3 Return aggregator account details
@enduml
</pre>

**1. Client starts flow with Aggregator Server**

The client begins by asking the Aggregator to bootstrap an authorization_code registration and indicate which
authorization server should be used. The Aggregator identifies the client application from the
`IDP_client_token` and responds with the public parameters required for the OIDC authorization request.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IDP_client_token>
Content-Type: application/json

{
  "registration_type": "authorization_code",
  "authorization_server": "https://as.example"
}
```
</div>

**1.2 Aggregator responds with public parameters**

The Aggregator generates the PKCE verifier/challenge pair plus a random `state`, persists them together with
the pending registration, and returns only the public portions (`aggregator_client_id`, `code_challenge`,
`code_challenge_method`, `state`) to the client application. The `authorization_server` value identifies the
UMA Authorization Server (AS) that governs access to resources exposed by the Aggregator. The aggregator uses
the `IDP_client_token` to identify the user's IdP and Application Client ID Document for the subsequent OIDC
exchange.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "aggregator_client_id": "https://aggregator.example/client.jsonld",
  "code_challenge": "1uLSZp2...",
  "code_challenge_method": "S256",
  "state": "1eb7c8f5..."
}
```
</div>

**2. Client sends the end-user through the IDP authorization endpoint**

Using the information supplied by the Aggregator, the client constructs an authorization request against the IdP.

<div class="example">
```http
GET https://idp.example/authorize?
    response_type=code&
    client_id=https%3A%2F%2Faggregator.example%2Fclient.jsonld&
    redirect_uri=https%3A%2F%2Fapp.example%2Fcallback&
    scope=openid%20webid%20offline_access&
    code_challenge=1uLSZp2...&
    code_challenge_method=S256&
    state=1eb7c8f5...
```
</div>

**2.1 IDP dereferences the Aggregator Client ID Document**

If the IDP does not already have the `aggregator_client_id` registered, it dereferences the Aggregatorâ€™s
Client ID Document to retrieve the client metadata (for example redirect URIs and other policy-required fields).

**3. User authenticates and consents at the IDP**

The IDP performs its usual login and consent screens, after which it issues an authorization_code tied to the
Aggregatorâ€™s client.

**4. IDP redirects the user agent back to the clientâ€™s redirect_uri**

The IDP redirects the user agent back to the client application with the authorization code and the original `state`.

<div class="example">
```http
HTTP/1.1 302 Found
Location: https://app.example/callback?code=SplxlOBeZQQYbYS6WxSbIA&state=1eb7c8f5...
```
</div>

**5. Client posts the authorization code back to the Aggregator**

The client sends the code, redirect URI, and echoed state to the registration endpoint so the Aggregator can finish the flow.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IDP_client_token>
Content-Type: application/json

{
  "registration_type": "authorization_code",
  "code": "SplxlOBeZQQYbYS6WxSbIA",
  "redirect_uri": "https://app.example/callback",
  "state": "1eb7c8f5..."
}
```
</div>

**5.1 Aggregator dereferences the client application's Client ID Document**

If no specific redirect URIs were given in the Client ID Document, the Aggregator dereferences the 
`https://app.example/client.jsonld` JSON-LD document to confirm the registered redirect URIs. The aggregator then verifies 
that the supplied `redirect_uri` belongs to that set and that the returned `state` matches the stored state.

**5.2 Aggregator redeems the authorization code at the IDP token endpoint**

<div class="example">
```http
POST /token HTTP/1.1
Host: idp.example
Content-Type: application/x-www-form-urlencoded
Authorization: Basic <aggregator-client-auth>

grant_type=authorization_code&
code=SplxlOBeZQQYbYS6WxSbIA&
redirect_uri=https%3A%2F%2Fapp.example%2Fcallback&
client_id=https%3A%2F%2Faggregator.example%2Fclient.jsonld&
code_verifier=Hjs8...stored...
```
</div>

The IDP verifies the authorization_code, ensures the redirect_uri matches the original authorization request,
and recomputes the PKCE challenge from the supplied `code_verifier`. If everything matches, it returns:

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "<IDP_aggregator_token>",
  "refresh_token": "<refresh_token>",
  "token_type": "Bearer",
  "expires_in": 3600
}
```
</div>

**5.3 Aggregator finalizes the account and responds**

Using the issued tokens, the Aggregator creates the aggregator account linked to the user and returns the
aggregator description ([[#aggregator-description]]).

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "aggregator": "https://aggregator.example/aggregators/agg-6780/"
}
```
</div>


### Creation `device_code` Flow ### {#creation-device-code}

The `device_code` flow allows headless components (for example CLI tools) to authenticate an Aggregator
Instance by using the OAuth 2.0 Device Authorization Grant [[RFC8628]].

<pre class="plantuml">
@startuml
skinparam participantStyle rectangle

participant User as "User ðŸ™‹"
participant Client as "Client ðŸ§‘â€ðŸ’»"
participant "Aggregator Server ðŸ¤–" as Aggregator
participant "IDP ðŸ”" as IDP

Client -> Aggregator: 1. Start device_code flow
Aggregator -> IDP: 1.1 Device authorization request
IDP --> Aggregator: device_code + user_code + verification_uri
Aggregator --> Client: 1.2 Return state + user_code + verification_uri

Client -> User: 2. Show code + verification URI
User -> IDP: 3. Authorize device

loop Polling until authorized or expired
Client -> Aggregator: 4. Poll with state
Aggregator -> IDP: 4.1 Redeem device_code
IDP --> Aggregator: pending / tokens
Aggregator --> Client: 202 Accepted or 201 Created
end
@enduml
</pre>

**1. Client starts flow with Aggregator Server**

The client calls the registration endpoint authenticated with its `IDP_client_token`, indicating the
authorization server that governs access to resources exposed by the Aggregator.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IDP_client_token>
Content-Type: application/json

{
  "registration_type": "device_code",
  "authorization_server": "https://as.example"
}
```
</div>

**1.1 Aggregator Server returns device authorization parameters**

The Aggregator requests device authorization parameters from the IdP and returns the user code,
verification URI(s), and polling state to the client.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "state": "state-abc",
  "user_code": "WDJB-MJHT",
  "verification_uri": "https://idp.example/activate",
  "verification_uri_complete": "https://idp.example/activate?user_code=WDJB-MJHT",
  "expires_in": 600,
  "interval": 5
}
```
</div>

**2. User authorizes at the IdP**

The client prompts the user to visit the verification URI and enter the user code to authorize access.

**3. Client polls Aggregator Server**

The client polls the registration endpoint using the `state` value, waiting at least the returned
`interval` (if provided) between polls. The Aggregator polls the IdP token endpoint using the stored
device code until the user authorizes or the device code expires.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IDP_client_token>
Content-Type: application/json

{
  "registration_type": "device_code",
  "state": "state-abc"
}
```
</div>

If authorization is not yet complete, the Aggregator responds with `202 Accepted`:

<div class="example">
```http
HTTP/1.1 202 Accepted
```
</div>

Once authorization succeeds, the Aggregator creates the Aggregator Instance and responds as for other
successful create operations:

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "aggregator": "https://aggregator.example/aggregators/agg-5670/"
}
```
</div>

**Example server-side token polling (Non-normative)**

While polling, the IdP can return an authorization-pending error:

<div class="example">
```http
POST /token HTTP/1.1
Host: idp.example
Content-Type: application/x-www-form-urlencoded

grant_type=urn:ietf:params:oauth:grant-type:device_code&
device_code=GmRhmhcxhwAzkoEqiMEg_DnyEysNkuNhszIySk9eS
```
</div>

<div class="example">
```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": "authorization_pending"
}
```
</div>

Once the user completes authorization, the IdP returns the token set:

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "<IDP_aggregator_token>",
  "refresh_token": "<refresh_token>",
  "token_type": "Bearer",
  "expires_in": 7200
}
```
</div>

### Token Update Flow ### {#token-update}

This flow allows users to replace the stored access token and refresh token for an existing Aggregator Instance.
This is not a refresh-token grant: even refresh tokens can expire, so the client repeats the original
registration flow to obtain a new set of tokens (and refresh tokens) for the Aggregator Instance.

The flow is the same as creating an Aggregator Instance but an `aggregator` member is provided in the start request.
The exact steps depend on the `registration_type` used when creating the Aggregator Instance.
For example, for the `authorization_code` flow:

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IDP_client_token>
Content-Type: application/json
{
    "registration_type": "authorization_code",
    "aggregator": "https://aggregator.example/aggregators/agg-7890/"
}
```
</div>

### Aggregator Listing Flow ### {#aggregator-listing}

This flow allows users to list Aggregator Instances by sending a `GET` request to the `registration_endpoint`.

<div class="example">
```http
GET /registration HTTP/1.1
Authorization: Bearer <IDP_client_token>
```
</div>

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: application/json

[
  "https://aggregator.example/aggregators/agg-7890/",
  "https://aggregator.example/aggregators/agg-9012/"
]
```
</div>

### Aggregator Deletion Flow ### {#aggregator-deletion}

This flow allows users to delete an existing Aggregator Instance by sending a `DELETE` request to the
`registration_endpoint` with the `aggregator` member.

<div class="example">
```http
DELETE /registration HTTP/1.1
Authorization: Bearer <IDP_client_token>
Content-Type: application/json
{
    "aggregator": "https://aggregator.example/aggregators/agg-7890/"
}
```
</div>
