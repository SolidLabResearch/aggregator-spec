Aggregator Registration (Provisioning) API {#aggregator-registration}
==================================================================
This section describes how aggregators are managed on the Aggregator Server level.
The authorization for these endpoints is defined by the implementation and up to the Aggregator provider to decide.
The user requires authenticated requests to manage their aggregator accounts on wich the Aggregator provider can base their authorization decisions.
The tokens used in these requests (IPD_client_token) prove the identity of the user and the client (ClientID) used to access the aggregator.

ISSUE: TODO add a defenition of the endpoint here, after we go into the flows of how they are used.

ISSUE: TODO add that after creation the aggregator should register the resources to the AS.

Aggregator Creation (Registration) {#aggregator-creation}
--------------------------------------------------------
This section describes how clients can create an Aggregator.
There exists different flows to create an aggregator depending on the registration type.

ISSUE: TODO where to add versioning info?

ISSUE: TODO where to use DPOP tokens?

ISSUE: TODO what about HTTP error handling?

ISSUE: TODO mention that the aggregator can be either host based or path based: {id}.aggregator.org or aggregator.org/{id}/

ISSUE: TODO the result of aggregator creation returns the ID and the base url of the aggregator (for example {id}.aggregator.org or aggregator.org/{id}/).

### `provision` Flow ### {#creation-provision}

The `provision` flow allows clients to create an Aggregator with its own identity.
This lets resource owners target access-control policies at the aggregatorâ€™s dedicated WebID instead of having the aggregator impersonate another userâ€™s WebID.

**1. Client starts flow with Aggregator Server**

The client calls the registration endpoint authenticated with its `IPD_client_token`.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json

{
  "registration_type": "provision",
}
```
</div>

**2. Aggregator Server provisions a WebID and registers it at the IDP**

The Aggregator Server creates a WebID document and registers a new account with an IDP for that WebID.
Using the credentials of this new account the Aggregator Server CAN perform a client credentials flow to obtain the `IDP_aggregator_token` (and accompanying refresh token) to authorize the aggregator acting under its own WebID.

ISSUE: TODO should this WebID specify that it is an aggregator/agent?

**3. Aggregator Server creates an aggregator**

Using the obtained tokens, the Aggregator Server creates an aggregator linked to the user, and returns the aggregator metadata and newly created WebID.
The aggregator CAN NOT give these tokens or client credentials to the client.


### `authorization_code` Flow ### {#creation-authorization}

The `authorization_code` flow allows clients to create an aggregator that acts on behalf of the end-user, but with a token that is scoped specifically for the aggregator.

<pre class="plantuml">
@startuml
skinparam participantStyle rectangle

participant Client as "Client ðŸ§‘â€ðŸ’»"
participant User as "User ðŸ™‹"
participant "Aggregator Server ðŸ¤–" as Aggregator
participant "User WebID ðŸ“„" as WebID
participant "Client ID ðŸ“„" as AppClientDoc
participant "IDP ðŸ”" as IDP

Client -> Aggregator: 1. Start aggregator creation
Aggregator <-> WebID: 1.1 Dereference WebID
Aggregator --> Client: 1.2 Return client_id, code_challenge, state

Client -> IDP: 2. Redirect to IDP login
IDP <-> User: 3. Authenticate and consent
IDP --> Client: 4. Redirect with code + state

Client -> Aggregator: 5. Return code + redirect_uri + state
Aggregator <-> AppClientDoc: 5.1 Dereference Client ID document
note over Aggregator: validate redirect_uri.
Aggregator -> IDP: 5.2 Redeem code
IDP --> Aggregator: IDP_aggregator_token + refresh_token

Aggregator --> Client: 5.3 Return aggregator account details
@enduml
</pre>

**1. Client starts flow with Aggregator Server**

The client begins by asking the Aggregator to bootstrap an authorization_code registration and indicate which authorization server should be used. The Aggregator responds with the public parameters required for the OIDC authorization request.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json

{
  "registration_type": "authorization_code",
  "authorization_server": "https://as.example"
}
```
</div>

**1.1 Aggregator dereferences the WebID to discover the IDP**

Using the UMA authorization context, the Aggregator dereferences the userâ€™s WebID profile document to locate the Solid/OIDC issuer metadata and determine which IDP endpoints must be used for the next steps.

**1.2 Aggregator responds with public parameters**

After finishing WebID discovery and storing the PKCE verifier/state, the Aggregator returns the public parameters required for the IDP authorization request.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "client_id": "https://aggregator.example/client.jsonld",
  "code_challenge": "1uLSZp2...",
  "code_challenge_method": "S256",
  "state": "1eb7c8f5..."
}
```
</div>

The Aggregator generates the PKCE verifier/challenge pair plus a random `state`, persists them together with the pending registration, and returns only the public portions (`client_id`, `code_challenge`, `state`) to the client application.
The `authorization_server` value identifies the UMA Authorization Server (AS) that governs resource policies; once the Aggregator evaluates the userâ€™s authorization token it can dereference its WebID and determine which Identity Provider (IDP) must be used for the subsequent OIDC exchange.

ISSUE: TODO How does the aggregator register with the AS?

**2. Client sends the end-user through the IDP authorization endpoint**

Using the information supplied by the Aggregator, the client constructs an authorization request against the Identity Provider.
The redirect_uri is under control of the client application and MUST already be registered in the JSON-LD client metadata document hosted at the dereferenceable `client_id`.

<div class="example">
```http
GET https://idp.example/authorize?
    response_type=code&
    client_id=https%3A%2F%2Faggregator.example%2Fclient.jsonld&
    redirect_uri=https%3A%2F%2Fapp.example%2Fcallback&
    scope=openid%20webid%20offline_access&
    code_challenge=1uLSZp2...&
    code_challenge_method=S256&
    state=1eb7c8f5...
```
</div>

**3. User authenticates and consents at the IDP**

The IDP performs its usual login and consent screens, after which it issues an authorization_code tied to the Aggregatorâ€™s confidential client.

**4. IDP redirects the user agent back to the clientâ€™s redirect_uri**

<div class="example">
```http
HTTP/1.1 302 Found
Location: https://app.example/callback?code=SplxlOBeZQQYbYS6WxSbIA&state=1eb7c8f5...
```
</div>

**5. Client posts the authorization code back to the Aggregator**

The client sends the code, redirect URI, and echoed state to the registration endpoint so the Aggregator can finish the flow.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json

{
  "registration_type": "authorization_code",
  "code": "SplxlOBeZQQYbYS6WxSbIA",
  "redirect_uri": "https://app.example/callback",
  "state": "1eb7c8f5..."
}
```
</div>

**5.1 Aggregator dereferences the client metadata**

The Aggregator dereferences the `client_id` JSON-LD document to confirm the registered redirect URIs, contact metadata, and other security requirements, then verifies that the supplied redirect_uri belongs to that set and that the returned `state` matches the stored nonce.

**5.2 Aggregator redeems the authorization code at the IDP token endpoint**

<div class="example">
```http
POST /token HTTP/1.1
Host: idp.example
Content-Type: application/x-www-form-urlencoded
Authorization: Basic <aggregator-client-auth>

grant_type=authorization_code&
code=SplxlOBeZQQYbYS6WxSbIA&
redirect_uri=https%3A%2F%2Fapp.example%2Fcallback&
client_id=https%3A%2F%2Faggregator.example%2Fclient.jsonld&
code_verifier=Hjs8...stored...
```
</div>

The IDP verifies the authorization_code, ensures the redirect_uri matches the original authorization request, and recomputes the PKCE challenge from the supplied `code_verifier`. If everything matches, it returns:

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "<IDP_aggregator_token>",
  "refresh_token": "<refresh_token>",
  "token_type": "Bearer",
  "expires_in": 3600
}
```
</div>

**5.3 Aggregator finalizes the account and responds**

Using the issued tokens, the Aggregator creates the aggregator account linked to the user and returns the aggregator account details to the client.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "aggregator_id": "agg-7890",
  "authorization_server": "https://as.example",
}
```
</div>


### `client_credentials` Flow ### {#creation-client-credentials}

The `client_credentials` flow allows clients to create an aggregator by using the OAuth2 Client Credentials Flow to obtain an OIDC token from an Identity Provider (IDP) server.

NOTE: This flow gives the aggregator complete access to the user's resources and policies without user consent.
This flow should only be used in trusted environments, or when a user creates an account for the aggregator.

**1. Client starts flow with Aggregator Server**

The client explicitly asks the Aggregator to act with full credentials for the provided WebID, indicating which UMA Authorization Server manages the protected resources.
Because this flow hands the Aggregator long-lived credentials, it should only be used when the user intentionally provisions the Aggregator as a trusted service account.

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json

{
  "registration_type": "client_credentials",
  "authorization_server": "https://as.example",
  "webid": "https://user.example/webid#me",
  "username": "alice@example.org",
  "password": "s3cr3t-password"
}
```
</div>

**2. Aggregator Server performs credential bootstrap with the IDP**

The Aggregator uses the supplied username/password (plus the WebID context) to authenticate against the Identity Providerâ€™s management or token endpoint, registering (or reusing) a confidential client that represents the Aggregatorâ€™s service account for that user. It then runs an OAuth 2.0 client_credentials grant using the obtained client_id/client_secret to mint an `IDP_aggregator_token` scoped to the userâ€™s WebID.

<div class="example">
```http
POST /token HTTP/1.1
Host: idp.example
Content-Type: application/x-www-form-urlencoded
Authorization: Basic <aggregator-client-auth>

grant_type=client_credentials&
webid=https%3A%2F%2Fuser.example%2Fwebid%23me&
scope=openid%20webid%20offline_access
```
</div>

The IDP issues access and refresh tokens that grant the Aggregator the same capabilities as the userâ€™s own credentials.

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "<IDP_aggregator_token>",
  "refresh_token": "<refresh_token>",
  "token_type": "Bearer",
  "expires_in": 7200
}
```
</div>

**3. Aggregator Server creates (or updates) the aggregator account**

Armed with the `IDP_aggregator_token`, the Aggregator persists the account for the specified WebID, associates it with the requesting user, and returns the aggregator account metadata (aggregator identifier, token expiry, UMA AS linkage, etc.) to the client.


### `device_code` Flow ### {#creation-device-code}

NOTE: TODO This flow is not yet specified.

Aggregator Login {#aggregator-login}
-------------------
The login flow allows users to update the tokens of their existing aggregator.
This flow can be used to refresh the tokens in case they have expired.
The flow is the same as with creating an aggregator but an aggregator_id parameter is provided in step 1.
The exact steps depend on the registration_type used when creating the aggregator.
For example for the `authorization_code` flow:

<div class="example">
```http
POST /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json
{
    "registration_type": "authorization_code",
    "aggregator_id": "agg-7890"
}
```
</div>

Aggregator Deletion {#aggregator-deletion}
-------------------
The delete flow allows users to delete their existing aggregator.
This flow is done by doing a DELETE request to the registration endpoint with the aggregator_id parameter.

<div class="example">
```http
DELETE /registration HTTP/1.1
Authorization: Bearer <IPD_client_token>
Content-Type: application/json
{
    "aggregator_id": "agg-7890"
}
```
</div>
