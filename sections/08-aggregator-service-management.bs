Aggregator Service Management {#aggregator-service-management}
==================================================================

The Aggregator Service Management endpoint gives an authenticated client a complete view on the Aggregator Services.
It lets an authenticated client see all the running Aggregator Services and create, inspect, and remove individual 
Aggregator Services. Implementations MAY use different URLs as long as the Aggregator Description document (described in
[[#aggregator-description]]) links to the concrete entry points. All described endpoints in this section MUST be protected 
by the authentication and authorization mechanisms defined in [[#aggregator-security-model]].

Service Collection Endpoint {#service-collection}
---------------------------------------------------------

ISSUE: Do we define the exact scopes here?

This endpoint allows to create and fetch the collection of configured Aggregator Services. The location of this resource is 
advertised in the Aggregator Description ([[#aggregator-description]]) via the `service_collection_endpoint` field.
Clients MUST treat that advertised URL as authoritative and MUST NOT assume a fixed path (the examples in this section use 
`/services` purely for illustration). The Aggregator MUST register this UMA resource with the Authorization Server and 
advertise the `read` and `create` scopes so that clients can both inspect and add members.

: `HEAD`
:: If the Service Collection exists, the server MUST respond with `200 OK`, `Content-Type: application/json`, and an `ETag` 
    header whose value changes whenever a service is added or removed. The `ETag` allows clients to detect collection 
    changes without re-downloading it. This request MUST be authorized with a `read` scope on the Service Collection 
    resource.

: `GET`
:: Returns the list of Aggregator Service resources ([[#service-resource]]). The server MUST set the same `ETag` value as 
    the `HEAD` response. This request MUST be authorized with a `read` scope on the Service Collection resource. The server 
    MUST support JSON and MAY additionally expose semantically annotated RDF representations (for example JSON-LD or Turtle) 
    using HTTP content negotiation based on [[RFC9110]]. The payload MUST include at least the following fields:

    : **services** (REQUIRED):
    :: The value is a JSON array of strings where each member MUST be an absolute URL of a Service Resource that can be 
        dereferenced by the client. In semantically annotated representations, this member maps to the predicate 
        `aggr:service` ([[#aggr-service-property]]).
    : **id** (OPTIONAL):
    :: The value is a string containing the absolute URL that identifies this Service Collection. This MUST be the same URL 
        as the request target. In semantically annotated representations, this is the RDF subject (i.e., `@id`) of the
        `aggr:ServiceCollection` resource ([[#aggr-service-collection-class]]).

    <div class="example">
    ```json
    {
      "@context": {
        "id": "@id",
        "services": {
          "@id": "aggr:service",
          "@container": "@set",
          "@type": "@id"
        },
        "aggr": "https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/#"
      },
      "id": "https://aggregator.example.org/services",
      "services": [
        "https://aggregator.example.org/services/410b093c-04b3-4fac-87be-4d393f40b2e5",
        "https://aggregator.example.org/services/42"
      ]
    }
    ```
    </div>

: `POST`
:: This request allows a client to create a new Aggregator Service. The request MUST be authorized with a `create` scope 
    on the Service Collection resource. The request body MUST contain an `fno:Execution` that references a transformation 
    from the public or instance-level transformation catalog, unless it references a client-provided `fno:Composition` 
    handled as described below (implementations MAY decide on the exact semantic media type using HTTP content negotiation 
    based on [[RFC9110]]). This execution description MUST conform to the FnO specification [[!FNO]] and MUST include 
    exactly one `fno:executes` with the IRI of the function to execute. The client SHOULD either use a blank node or an IRI 
    as the subject of the `fno:Execution`, using an IRI allows the client to suggest a specific identifier for the created 
    service. Servers MAY honor this suggested identifier; if they do, the created service URL MUST equal the suggested IRI.
    Servers that do not honor client-suggested identifiers MUST ignore the suggestion and generate their own identifier.
    If `fno:executes` references a `fno:Composition` provided by the client, the server MUST either reject the
    request with `400 Bad Request` or accept it and publish the composition in the instance-level transformation catalog.
    On success, the server MUST:
      1. Persist the new service and change the collection `ETag`.
      2. Register a new UMA resource for the created Service Resource URL (e.g., `/services/{service_id}`) with the `read` 
        and `delete` scopes so the creator—or any other party with an RPT containing those scopes—can manage the service.
      3. Return `201 Created`, with the Aggregator Service resource representation (as defined in [[#service-resource]]) 
        in the response body.

    If the request body is invalid the server MUST respond with `400 Bad Request`. Failures while instantiating
    the service MUST result in `500 Internal Server Error`. If the server honors a suggested identifier and the suggested 
    identifier is not available, the server MUST respond with `409 Conflict`.

Service Resource {#service-resource}
-------------------------------------------------------------------------------

Operations on the service resource MUST require the `read` scope for `HEAD` and `GET` requests and the `delete` scope for 
`DELETE` requests. The service resource URL MUST be one of the URLs returned by the collection resource; a request for a 
non-existent service MUST return `404 Not Found`, while malformed service URLs MUST yield `400 Bad Request`. In 
semantically annotated representations, the service resource MUST also be typed as `fno:Execution`.

: `HEAD`
:: If the Service Resource exists, the server MUST respond with `200 OK` and `ETag`, and `Content-Type` headers
    whose value MUST change whenever the service state changes.

: `GET`
:: If no `Accept` header was set by the user, a JSON representation of the service MUST be returned with `200 OK` and 
    with a `Content-Type: application/json`. The user MAY request semantic representations using HTTP content negotiation 
    based on [[RFC9110]]. The representation MUST include at least the following fields:

    : **id** (REQUIRED):
    :: The value is a string containing the absolute URL of this Service Resource. In semantically annotated 
        representations, this is the RDF subject (i.e., `@id`) of the `aggr:Service` class ([[#aggr-service-class]]).

    : **type** (REQUIRED):
    :: The value is a array of strings indicating the RDF types of this service. This array MUST include `aggr:Service` and 
        `fno:Execution`. In semantically annotated representations, this represents the type (`@type` in JSON-LD) of the 
        service.

    : **status** (REQUIRED):
    :: The value is a string indicating the current status of the service (e.g., `"starting"`, `"running"`, `"stopped"`, or 
        `"errored"`). In semantically annotated representations, this member maps to the predicate `aggr:status`
        ([[#aggr-status-property]]).

    : **status_detail** (OPTIONAL):
    :: The value is a string providing a human-readable detail about the current status (for example, a stop reason or 
        error message). When `status` is `"errored"`, the server SHOULD include this field. In semantically annotated 
        representations, this member maps to the predicate `aggr:statusDetail` ([[#aggr-status-detail-property]]).

    : **created_at** (REQUIRED):
    :: The value is a string timestamp (recommended: `xsd:dateTime` lexical form, e.g., RFC 3339 [[RFC3339]]). In 
        semantically annotated representations, this member maps to the predicate `aggr:createdAt` 
        ([[#aggr-created-at-property]]).

    : **executes** (REQUIRED):
    :: The value is a string containing the IRI of the FnO function being executed. In semantically annotated 
        representations, this member maps to the predicate `fno:executes`.

    The representation MUST also include any required input and output parameters for the executed FnO function, using the 
    FnO parameters and outputs predicates defined in the function's FnO description. The representation MAY include 
    additional fields (e.g., `fno:name`, `fno:solves`, etc.) as needed. The specification does not mandate a specific
    serialization for these additional fields; clients MUST be prepared to handle arbitrary RDF properties in semantically 
    annotated representations.

: `DELETE`
:: Stops and removes the service. The Aggregator MUST stop the running transformation, delete the persisted service entry, 
    change the collection `ETag`, unregister the service’s UMA resource, and respond with `204 No Content`. Clients that 
    held the service identifier MUST treat it as invalid after receiving the success response.

Service Management Flows (Non-normative) {#service-management-flows}
----------------------------------------

This section gives some examples on how a client can create, find, use and delete services on the Aggregator. This section 
is non-normative, and is only meant to illustrate the usage of the various endpoints defined in this specification. This 
section assumes the client has already created an Aggregator using the Aggregator Registration API 
([[#aggregator-registration]]) and is able to authenticate using the mechanisms defined in [[#aggregator-security-model]].

### Creating a Service ### {#creating-a-service}

To create a new Aggregator Service, a client starts by doing a `POST` request to the Service Collection endpoint (i.e., the 
URL advertised via `service_collection_endpoint` in the Aggregator Description; this section uses `/services` as an 
example). The body of the post is an execution of an FnO function [[!FNO]].

<div class="example">
```http
POST /services HTTP/1.1
Host: aggregator.example.org
Content-Type: text/turtle

@prefix trans: <http://aggregator.example.org/transformations#> .
@prefix fno: <https://w3id.org/function/ontology#> .

_:execution a fno:Execution ;
    fno:executes trans:QuerySources ;
    trans:query "SELECT * WHERE { ?s ?p ?o }" ;
    trans:sources ( <http://example.org/source/1> <http://example.org/source/2> ) .
```
</div>

The Aggregator fetches a ticket from the Authorization Server with the resource_id `1a2b-creation-endpoint` it got during 
asset creation (see [[!A4DS]]).

<div class="example">
```http
HTTP/1.1 /ticket
Host: as.example.org
Content-Type: application/json
{
    "resource_id": "1a2b-creation-endpoint",
    "resource_scopes": ["https://example.org/modes/create"]
}
```
</div>

This returns a ticket that represents the permissions needed for this request to the RS (the Aggregator in this case).

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: application/json
{
    "ticket": "service-creation-ticket-xyz"
}
```
</div>

This ticket is then returned to the client in a `401 Unauthorized` response.

<div class="example">
```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA as_uri="https://as.example.org", ticket="service-creation-ticket-xyz"
```
</div>

The client then requests an RPT from the AS using the ticket, as defined in [[#aggregator-security-model]].
The original request can then be retried, this time including the RPT in the `Authorization` header.

<div class="example">
```http
POST /services HTTP/1.1
Host: aggregator.example.org
Authorization: Bearer ey...
Content-Type: text/turtle

@prefix trans: <http://aggregator.example.org/transformations#> .
@prefix fno: <https://w3id.org/function/ontology#> .

_:execution a fno:Execution ;
    fno:executes trans:QuerySources ;
    trans:query "SELECT * WHERE { ?s ?p ?o }" ;
    trans:sources ( <http://example.org/source/1> <http://example.org/source/2> ) .
```
</div>

If the request is valid, the Aggregator will create a new service, register the appropriate UMA resource, and
return a `201 Created` response with the service representation in the body.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: text/turtle

@prefix aggr: <https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/#> .
@prefix fno: <https://w3id.org/function/ontology#> .
@prefix trans: <http://aggregator.example.org/transformations#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<https://aggregator.example.org/services/410b093c-04b3-4fac-87be-4d393f40b2e5>
    a aggr:Service ;
    a fno:Execution ;
    aggr:status "running" ;
    aggr:statusDetail "" ;
    aggr:createdAt "2024-01-01T12:00:00Z"^^xsd:dateTime ;
    fno:executes trans:QuerySources ;
    trans:query "SELECT * WHERE { ?s ?p ?o }" ;
    trans:sources ( <http://example.org/source/1> <http://example.org/source/2> ) ;
    trans:result <https://aggregator.example.org/services/410b093c-04b3-4fac-87be-4d393f40b2e5#result> .

<https://aggregator.example.org/services/410b093c-04b3-4fac-87be-4d393f40b2e5#result>
    a trans:SPARQLProtocol ;
    dcat:endpointURL <https://aggregator.example.org/410b093c-04b3-4fac-87be-4d393f40b2e5/> .
```
</div>

### Discovering Services ### {#discovering-services}

To discover the services currently registered on the Aggregator, a client can do a `GET` request to the
Service Collection endpoint (this section uses `/services` as an example).
After authenticating using the mechanisms defined in [[#aggregator-security-model]], the Aggregator will
return a list with the registered service from [[#creating-a-service]].

<div class="example">
```http
HTTP/1.1 200 OK
Content-Type: text/turtle

@prefix aggr: <https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
<> a aggr:ServiceCollection ;
    aggr:service <https://aggregator.example.org/services/410b093c-04b3-4fac-87be-4d393f40b2e5> .
```
</div>

Dereferencing this URL will return the full service representation.

<div class="example">
```http
HTTP/1.1 201 Created
Content-Type: text/turtle

@prefix aggr: <https://spec.knows.idlab.ugent.be/aggregator-protocol/latest/#> .
@prefix fno: <https://w3id.org/function/ontology#> .
@prefix trans: <http://aggregator.example.org/transformations#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<https://aggregator.example.org/services/410b093c-04b3-4fac-87be-4d393f40b2e5>
    a aggr:Service ;
    a fno:Execution ;
    aggr:status "starting" ;
    aggr:statusDetail "" ;
    aggr:createdAt "2024-01-01T12:00:00Z"^^xsd:dateTime ;
    fno:executes trans:QuerySources ;
    trans:query "SELECT * WHERE { ?s ?p ?o }" ;
    trans:sources ( <http://example.org/source/1> <http://example.org/source/2> ) ;
    trans:result <https://aggregator.example.org/services/410b093c-04b3-4fac-87be-4d393f40b2e5#result> .

<https://aggregator.example.org/services/410b093c-04b3-4fac-87be-4d393f40b2e5#result>
    a trans:SPARQLProtocol ;
    dcat:endpointURL <https://aggregator.example.org/410b093c-04b3-4fac-87be-4d393f40b2e5/> .
```
</div>

### Using a Simple Service ### {#using-a-service}

After discovering the service, the client can use the transformation catalog to find out what `trans:QuerySources` does,
and how to use the output. In this example, the client sees that the function produces an output parameter `trans:result` 
that is a `trans:SPARQLProtocol` conforming to the SPARQL protocol with an endpointURL at 
`https://aggregator.example.org/410b093c-04b3-4fac-87be-4d393f40b2e5/` where the query results can be accessed. The client 
can then do a `GET` request to that URL, again authenticating using the mechanisms defined in 
[[#aggregator-security-model]]. This time the client might need to gather multiple access claims from the AS's of 
`http://example.org/source/1` and `http://example.org/source/2`. After receiving an access token from the Aggregator 
Authorization Server, the client can redo the `GET` request to 
`https://aggregator.example.org/410b093c-04b3-4fac-87be-4d393f40b2e5/` to get the query results.
